import {
  __publicField
} from "./chunk-2B2CG5KL.js";

// node_modules/jwt-decode/build/jwt-decode.esm.js
function e(e2) {
  this.message = e2;
}
e.prototype = new Error(), e.prototype.name = "InvalidCharacterError";
var r = "undefined" != typeof window && window.atob && window.atob.bind(window) || function(r2) {
  var t2 = String(r2).replace(/=+$/, "");
  if (t2.length % 4 == 1)
    throw new e("'atob' failed: The string to be decoded is not correctly encoded.");
  for (var n2, o2, a = 0, i = 0, c = ""; o2 = t2.charAt(i++); ~o2 && (n2 = a % 4 ? 64 * n2 + o2 : o2, a++ % 4) ? c += String.fromCharCode(255 & n2 >> (-2 * a & 6)) : 0)
    o2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(o2);
  return c;
};
function t(e2) {
  var t2 = e2.replace(/-/g, "+").replace(/_/g, "/");
  switch (t2.length % 4) {
    case 0:
      break;
    case 2:
      t2 += "==";
      break;
    case 3:
      t2 += "=";
      break;
    default:
      throw "Illegal base64url string!";
  }
  try {
    return function(e3) {
      return decodeURIComponent(r(e3).replace(/(.)/g, function(e4, r2) {
        var t3 = r2.charCodeAt(0).toString(16).toUpperCase();
        return t3.length < 2 && (t3 = "0" + t3), "%" + t3;
      }));
    }(t2);
  } catch (e3) {
    return r(t2);
  }
}
function n(e2) {
  this.message = e2;
}
function o(e2, r2) {
  if ("string" != typeof e2)
    throw new n("Invalid token specified");
  var o2 = true === (r2 = r2 || {}).header ? 0 : 1;
  try {
    return JSON.parse(t(e2.split(".")[o2]));
  } catch (e3) {
    throw new n("Invalid token specified: " + e3.message);
  }
}
n.prototype = new Error(), n.prototype.name = "InvalidTokenError";
var jwt_decode_esm_default = o;

// node_modules/isomorphic-ws/browser.js
var ws = null;
if (typeof WebSocket !== "undefined") {
  ws = WebSocket;
} else if (typeof MozWebSocket !== "undefined") {
  ws = MozWebSocket;
} else if (typeof global !== "undefined") {
  ws = global.WebSocket || global.MozWebSocket;
} else if (typeof window !== "undefined") {
  ws = window.WebSocket || window.MozWebSocket;
} else if (typeof self !== "undefined") {
  ws = self.WebSocket || self.MozWebSocket;
}
var browser_default = ws;

// node_modules/@hathora/client-sdk/lib/connection.js
var HathoraConnection = class {
  constructor(roomId, connectionInfo) {
    __publicField(this, "roomId");
    __publicField(this, "connectionInfo");
    __publicField(this, "socket");
    __publicField(this, "messageListeners", []);
    __publicField(this, "closeListeners", []);
    __publicField(this, "stringEncoder", new TextEncoder());
    __publicField(this, "stringDecoder", new TextDecoder());
    this.roomId = roomId;
    this.connectionInfo = connectionInfo;
  }
  onMessage(listener) {
    this.messageListeners.push(listener);
  }
  onMessageString(listener) {
    this.messageListeners.push((buf) => {
      listener(this.stringDecoder.decode(buf));
    });
  }
  onMessageJson(listener) {
    this.onMessageString((str) => {
      listener(JSON.parse(str));
    });
  }
  onClose(listener) {
    this.closeListeners.push(listener);
  }
  async connect(token) {
    const { host, port, transportType } = this.connectionInfo;
    this.socket = new browser_default(`${transportType === "tls" ? "wss" : "ws"}://${host}:${port}/${this.roomId}?token=${token}`);
    this.socket.binaryType = "arraybuffer";
    return new Promise((resolve, reject) => {
      this.socket.onopen = () => {
        resolve();
      };
      this.socket.onclose = (e2) => {
        reject(e2.reason);
        this._onClose(e2);
      };
      this.socket.onmessage = ({ data }) => {
        if (!(data instanceof ArrayBuffer)) {
          throw new Error("Unexpected data type: " + typeof data);
        }
        this._onMessage(data);
      };
    });
  }
  write(data) {
    var _a;
    (_a = this.socket) == null ? void 0 : _a.send(data);
  }
  writeString(data) {
    this.write(this.stringEncoder.encode(data));
  }
  writeJson(data) {
    this.writeString(JSON.stringify(data));
  }
  disconnect(code) {
    if (code === void 0) {
      this.socket.onclose = () => {
      };
    }
    this.socket.close(code);
  }
  _onMessage(data) {
    this.messageListeners.forEach((listener) => listener(data));
  }
  _onClose(e2) {
    this.closeListeners.forEach((listener) => listener(e2));
  }
};

// node_modules/@hathora/client-sdk/lib/client.js
var HathoraClient = class {
  constructor(appId, localConnectionDetails) {
    __publicField(this, "appId");
    __publicField(this, "localConnectionDetails");
    this.appId = appId;
    this.localConnectionDetails = localConnectionDetails;
  }
  static getUserFromToken(token) {
    return jwt_decode_esm_default(token);
  }
  async loginAnonymous() {
    const res = await this.postJson(`https://api.hathora.dev/auth/v1/${this.appId}/login/anonymous`, {});
    return res.token;
  }
  async loginNickname(nickname) {
    const res = await this.postJson(`https://api.hathora.dev/auth/v1/${this.appId}/login/nickname`, { nickname });
    return res.token;
  }
  async loginGoogle(idToken) {
    const res = await this.postJson(`https://api.hathora.dev/auth/v1/${this.appId}/login/google`, { idToken });
    return res.token;
  }
  async createPrivateLobby(token, { region = "Washington_DC", initialConfig = {} } = {}) {
    const visibility = this.localConnectionDetails !== void 0 ? "local" : "private";
    const { roomId } = await this.postJson(`https://api.hathora.dev/lobby/v2/${this.appId}/create`, { visibility, region, initialConfig }, { Authorization: token });
    return roomId;
  }
  async createPublicLobby(token, { region = "Washington_DC", initialConfig = {} } = {}) {
    const visibility = this.localConnectionDetails !== void 0 ? "local" : "public";
    const { roomId } = await this.postJson(`https://api.hathora.dev/lobby/v2/${this.appId}/create`, { visibility, region, initialConfig }, { Authorization: token });
    return roomId;
  }
  async getPublicLobbies(token, region) {
    const regionParam = region === void 0 ? "" : `?region=${region}`;
    const res = await fetch(`https://api.hathora.dev/lobby/v2/${this.appId}/list/public${regionParam}`, { headers: { Authorization: token } });
    return await res.json();
  }
  async getConnectionDetailsForRoomId(roomId) {
    if (this.localConnectionDetails !== void 0) {
      return this.localConnectionDetails;
    }
    const res = await fetch(`https://api.hathora.dev/rooms/v1/${this.appId}/connectioninfo/${roomId}`);
    const connectionInfo = await res.json();
    if (connectionInfo.status === "starting") {
      return new Promise((resolve) => {
        setTimeout(() => {
          resolve(this.getConnectionDetailsForRoomId(roomId));
        }, 1e3);
      });
    }
    return connectionInfo;
  }
  async newConnection(roomId) {
    const connectionDetails = await this.getConnectionDetailsForRoomId(roomId);
    return new HathoraConnection(roomId, connectionDetails);
  }
  async postJson(url, body, headers = {}) {
    const res = await fetch(url, {
      method: "POST",
      headers: { ...headers, "Content-Type": "application/json" },
      body: JSON.stringify(body)
    });
    return await res.json();
  }
};
export {
  HathoraClient,
  HathoraConnection
};
//# sourceMappingURL=@hathora_client-sdk.js.map
